
# [0347. Top K Frequent Elements - M](https://leetcode.com/problems/top-k-frequent-elements/description/)

`Difficult: Medium`
`Topics: Array, Hash Table, Divide and Conquer, Sorting, Heap (Priority Queue), Bucket Sort, Counting, Quickselect`

Given an integer array `nums` and an integer `k`, return the `k` most frequent elements. You may return the answer in any order.


 
 ```java
Example 1:

Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]
Example 2:

Input: nums = [1], k = 1
Output: [1]
```
- **Follow up**: Your algorithm's time complexity must be better than `O(n log n)`, where `n` is the array's size.
## [Solution 1: ](https://leetcode.com/problems/top-k-frequent-elements/submissions/1671990801/)

### Idea
- Build `freqMinMap`.
- Transverse `freqMinMap` and insert on `minFreqHeap` and keeping it of size `k`.
- Poll `minFreqHeap` elements into new int[k] and return it
  

### Complexity
**TC:** O(n) ; **SC:** O(n)

### Code
```java
public int[] topKFrequent(int[] nums, int k) {
    // 1. Count Frequent. <num : freq>
    Map<Integer, Integer> freqMinMap = new TreeMap<>();
    for (int num : nums){
        freqMinMap.merge(num, 1, Integer::sum);
    }

    // 2. Keep top K Frequent elements. [num , freq]
    Queue<int[]> freqMinHeap = new PriorityQueue<>((a,b) -> a[1] - b[1]);
    for (var entry : freqMinMap.entrySet()){
        freqMinHeap.offer(new int[]{entry.getKey(), entry.getValue()});
        if (freqMinHeap.size() > k){
            freqMinHeap.poll();
        }
    }

    // 3. Save  result
    int[] result = new int[k];
    while(k-- > 0){
        result[k] = freqMinHeap.poll()[0];
    }
    return result;        
}
```


## [Solution 2: ](link)

### Idea
#### Mnemonic
#### Steps

### Complexity
**TC:**

**SC:**

### Code
```java

```